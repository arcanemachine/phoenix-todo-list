#!/bin/sh

service_name="phoenix-todo-list"
service_file="${HOME}/systemd/user/${service_name}.service"

if [ "$1" = "--help" ]; then
	echo "This script generates a user-level systemd service file.

The output will be sent here:
  - '$service_file'

After running this script, you will need to reload the systemd daemons:
  - systemctl --user daemon-reload

To enable this service:
  - systemctl --user enable $service_name.service

To start this service:
  - systemctl --user start $service_name.service

In order to start this service on boot, you must enabling lingering for this user:
  - sudo loginctl enable-linger $USER

If you are having issues with the service, you can examine the logs:
  - journalctl --user -xe --unit $service_name"
	exit 0
fi

current_script_directory="$(dirname "$0")"
project_root_directory="$(cd "${current_script_directory}/../../" && pwd)"
working_directory="${project_root_directory}/support/containers"

# navigate to current script directory
cd "$current_script_directory" || exit 1

# source dotenv
if [ "$DRY_RUN" != 1 ]; then
	echo "Importing environment from '${project_root_directory}/.env'..."
fi

set -o allexport
# shellcheck source=/dev/null
. "${project_root_directory}/.env"
set +o allexport

# for DRY_RUN, print output to terminal instead of writing to a file
if [ "$DRY_RUN" = 1 ]; then
	output_to=/dev/stdout
else
	output_to="${HOME}/.config/systemd/user/${service_name}.service"
fi

if [ "$DRY_RUN" != 1 ]; then
	echo "Creating systemd service file: '${output_to}'"
fi

# generate the service file
podman_socket_path=$(podman info --format '{{.Host.RemoteSocket.Path}}')
containers_to_run="-f compose.phoenix.yaml -f networks/compose.phoenix-host.yaml -f compose.postgres.yaml -f networks/compose.postgres-host.yaml"

echo "[Unit]
Description=$service_name
Wants=network-online.target
After=network-online.target
Requires=podman.service
RequiresMountsFor=/run/user/$(id -u)/containers

[Service]
# docker
Environment=COMPOSE_DOCKER_CLI_BUILD=0
Environment=IMAGE_TAG=\"$IMAGE_TAG\"

# phoenix
Environment=PHX_HOST=\"$PHX_HOST\"
Environment=PORT=\"$PORT\"
Environment=SECRET_KEY_BASE=\"$SECRET_KEY_BASE\"

# db
Environment=DATABASE_URL=\"$DATABASE_URL\"
Environment=POSTGRES_DB=\"$POSTGRES_DB\"
Environment=POSTGRES_USER=\"$POSTGRES_USER\"
Environment=POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\"

# # traefik
# Environment=TRAEFIK_HOST=\"$TRAEFIK_HOST\"

# # email
# Environment=AWS_REGION=\"$AWS_REGION\"
# Environment=AWS_ACCESS_KEY=\"$AWS_ACCESS_KEY\"
# Environment=AWS_SECRET=\"$AWS_SECRET\"

Restart=on-failure
WorkingDirectory=${working_directory}
# Type=forking

# Shutdown container (if running) when unit is started
ExecStartPre=$(which docker-compose) -H unix:${podman_socket_path} $containers_to_run down

# Start container when unit is started
ExecStart=$(which docker-compose) -H unix:${podman_socket_path} $containers_to_run up --remove-orphans

# Stop all services
ExecStop=$(which docker-compose) -H unix:${podman_socket_path} $containers_to_run down -t 5

[Install]
WantedBy=default.target" >"${output_to}"

if [ "$DRY_RUN" != 1 ]; then
	echo "done"
fi
