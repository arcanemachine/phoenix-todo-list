#!/bin/sh
# shellcheck disable=SC2153  # ignore inaccurate warning

service_name="phoenix-todo-list"
service_file="${HOME}/systemd/user/${service_name}.service"

if [ "$1" = "--help" ]; then
  echo "This script generates a user-level systemd service file.


Optional arguments:

  --docker - Use Docker instead of Podman.
    - If not set, environment will be configured for local use (i.e. no HTTPS).

  --postgres - Enables the use of a Postgres server container when running the service.

  --traefik-client - Configures the service to be used with Traefik.
    - This flag does not run a Traefik server. It just configures the service to work with a Traefik server defined elsewhere on the server.

  --traefik-host - Runs a Traefik container as part of the service.

  --remote - Configures the service for a remote environment (i.e. uses HTTPS).
    - This flag only affects Traefik-based setups. It will have no effect if you are not using Traefik.
    - If not set, the containers will be configured for local use (i.e. no HTTPS).

  --dry-run - Only displays the output of this script. Does not write any files.


After running this script:

The output will be sent here:
  - '$service_file'

Before you can manage the systemd service, you will need to reload the systemd daemons:
  - systemctl --user daemon-reload

To enable this service:
  - systemctl --user enable $service_name.service

To start this service:
  - systemctl --user start $service_name.service

In order to start this service on boot, you must enabling lingering for this user:
  - sudo loginctl enable-linger $USER

If you are having issues with the service, you can examine the logs:
  - journalctl --user -xe --unit $service_name"
  exit 0
fi

current_script_directory="$(dirname "$0")"
project_root_directory="$(cd "${current_script_directory}/../../" && pwd)"
working_directory="${project_root_directory}/support/containers"

# parse args
while test $# -gt 0; do
  case "$1" in
  --docker)
    # use docker instead of podman
    use_docker=1
    ;;
  --postgres)
    # run a postgres server as part of the service
    use_postgres=1
    ;;
  --traefik-client)
    # configure the service for use with traefik, but don't start a traefik server
    traefik_client=1
    ;;
  --traefik-host)
    # configure the service for use with traefik and start a traefik server
    traefik_host=1
    ;;
  --remote)
    # configure traefik for use in a remote environment (i.e. uses HTTPS)
    is_remote=1
    ;;
  --dry-run)
    # print output to console; do not write any files
    dry_run=1
    ;;
  esac
  shift
done

# validate args - do not allow '--traefik-client' and '--traefik-host' to be
# passed at the same time
if [ "$traefik_client" = 1 ] && [ "$traefik_host" = 1 ]; then
  echo "\033[91mYou cannot pass the '--traefik-client' and '--traefik-host' flags at the same time.\033[39m
If you only need to add the labels so an existing Traefik container can detect this service, pass the '--traefik-client' flag.
If you want to start a Traefik container as part of this service, pass the '--traefik-host' flag. This flag will also add the necessary labels to the web server container.
Aborting..."
  exit 1
fi

# navigate to current script directory
cd "$current_script_directory" || exit 1

# source dotenv
if [ "$dry_run" != 1 ]; then
  echo "Importing environment from '${project_root_directory}/.env'..."
fi

set -o allexport
# shellcheck source=/dev/null
. "${project_root_directory}/.env"
set +o allexport

# use_docker
if [ ! $use_docker ]; then
  # configure service for use with podman
  podman_socket_path=$(podman info --format '{{.Host.RemoteSocket.Path}}')
  maybe_podman_config="-H unix:${podman_socket_path}"
fi

# is_remote
if [ $is_remote ]; then
  local_or_remote="remote"
else
  local_or_remote="local"
fi

# containers_to_run #
# phoenix
containers_to_run="-f compose.phoenix.yaml"

if [ $traefik_client ] || [ $traefik_host ]; then
  containers_to_run="$containers_to_run -f networks/compose.phoenix-traefik.yaml -f compose.phoenix-config-traefik-${local_or_remote}.yaml"
else
  containers_to_run="$containers_to_run -f networks/compose.phoenix-host.yaml"
fi

# postgres
if [ $use_postgres ]; then
  containers_to_run="$containers_to_run -f compose.phoenix-postgres.yaml -f compose.postgres.yaml"

  # postgres + traefik
  if [ $traefik_client ] || [ $traefik_host ]; then
    containers_to_run="$containers_to_run -f networks/compose.postgres-traefik.yaml"
  else
    containers_to_run="$containers_to_run -f networks/compose.postgres-host.yaml"
  fi
fi

# traefik
if [ $traefik_host ]; then
  # run traefik container
  containers_to_run="$containers_to_run -f traefik/compose.yaml -f traefik/compose.config-${local_or_remote}.yaml"
fi

# for dry_run, print output to terminal instead of writing to a file
if [ "$dry_run" = 1 ]; then
  output_to=/dev/stdout
else
  output_to="${HOME}/.config/systemd/user/${service_name}.service"
fi

if [ "$dry_run" != 1 ]; then
  echo "Creating systemd service file: '${output_to}'"
fi

# generate the service file

echo "[Unit]
Description=$service_name
Wants=network-online.target
After=network-online.target
Requires=podman.service
RequiresMountsFor=/run/user/$(id -u)/containers

[Service]
# docker
Environment=COMPOSE_DOCKER_CLI_BUILD=0
Environment=IMAGE_TAG=\"$IMAGE_TAG\"

# phoenix
Environment=PHX_HOST=\"$PHX_HOST\"
Environment=PORT=\"$PORT\"
Environment=SECRET_KEY_BASE=\"$SECRET_KEY_BASE\"

# db
Environment=DATABASE_URL=\"$DATABASE_URL\"
Environment=POSTGRES_DB=\"$POSTGRES_DB\"
Environment=POSTGRES_USER=\"$POSTGRES_USER\"
Environment=POSTGRES_PASSWORD=\"$POSTGRES_PASSWORD\"

# # traefik
# Environment=TRAEFIK_HOST=\"$TRAEFIK_HOST\"

# # email
# Environment=AWS_REGION=\"$AWS_REGION\"
# Environment=AWS_ACCESS_KEY=\"$AWS_ACCESS_KEY\"
# Environment=AWS_SECRET=\"$AWS_SECRET\"

Restart=on-failure
WorkingDirectory=${working_directory}
# Type=forking

# Shutdown container (if running) when unit is started
ExecStartPre=/home/$USER/.local/bin/docker-compose ${maybe_podman_config} $containers_to_run down

# Start container when unit is started
ExecStart=/home/$USER/.local/bin/docker-compose ${maybe_podman_config} $containers_to_run up --remove-orphans

# Stop all services
ExecStop=/home/$USER/.local/bin/docker-compose ${maybe_podman_config} $containers_to_run down -t 5

[Install]
WantedBy=default.target" >"${output_to}"
